# 0727 필기
## 1. 객체지향 프로그래밍(OOP)
> 면접에 많이 나옴!!
### 1) 객체지향 프로그래밍이란?
> 컴퓨터 프로그래밍의 패러다임(방법론) 중 하나이다.
ex. 라면스프/면 패러다임
=> 라면을 끓이는 여러 방법 중 스프/면를(을) 먼저넣는 패러다임

- 객체는 정보와 행동으로 나뉘어짐
-> 정보와 행동이 있는 모든 물체는 객체다!
- 변수는 정보만 들어가는 것이므로 객체는 **정보+함수**라고도 말할 수 있음
ex) 가수 객체-{정보 : 키, 행동:노래, 춤}, 강아지 객체-{정보:리트리버, 행동: 먹기} 
- 객체간의 상호작용을 할 수 있음
ex) 교수가 강아지에게 사료를 준다

##### cf) 절차지향 프로그래밍
함수1 - 함수2 - 함수3 - 함수4 - 결과
=> 수정이 어려움, 하나를 변경하면 나머지들도 같이 변경해야 했음
==> 객체지향 프로그래밍을 사용

- 사용자 기준으로 객체들을 묶어, 각 객체 간 상호작용으로 프로그래밍을 작성함
=> 추상화 : 복잡한 것은 숨기고 필요한 것만 드러냄
ex) 가수.노래() : 가수가 노래를 어떻게 부르는지 몰라도 결과만 볼 수 있음


##### 장점
- 영역을 명확하게 나눌 수 있기 때문에, 많은 인원이 참여하는 대규모 SW개발에 적합 (역할 분배)
- 필요한 부분만 수정하기 쉽기 때문에, 프로그램의 유지보수가 쉬움
ex) 무대 준비를 위해 여러 역할(조명, 특수효과, 무대연출 등)로 나눠서 무대를 만듦
만약 가수에 문제가 있다면 가수만 바꾸면 문제가 해결됨

##### 단점
- 설계에 노력, 시간이 많이 필요 => 알고리즘에는 거의 사용안함
- 실행 속도가 상대적으로 느림 (사람이 편하면, 컴퓨터가 힘들다..)



### 2) OOP
- 객체 : 속성(**정보**; 변수)과 행동(**동작**; 함수-메서드)으로 구성된 모든 것
    - ex) 이찬혁.랩하기() -> '힙합은 안멋져..', 이찬혁.직업() -> 가수
- 클래스 : 설계도(추상적인) 같은 것으로, 객체는 그 중 실제 사례라고 볼 수 있음
    '*클래스*를 만든다 == *타입*을 만든다'
    - ex) 보통 강아지란? 클래스는 개념적인 것으로 실제 '강아지'라는 것은 없음(설계도) -> 리트리버, 시츄(실제 예시)

    - cf) 인스턴스 : 클래스로 만든 객체를 인스턴스라고 함 
         -특정 클래스의 인스턴스(종속된 형태)

###### "파이썬은 객체지향프로그래밍이다" = "정보와 행동을 가지고 있다!"
- 객체는 특정 타입(int, string, list)의 인스턴스이다!
    ##### [객체]
    - 타입 : 어떤 연산자와 조작이 가능한가?
        문자열+문자열, 숫자+숫자는 서로 다르게 동작함
    - 속성 : 어떤 상태(데이터)를 가지는가?
    - 조작법 : 어떤 행위(함수)를 할 수 있는가?
    => 객체는 속성(상태, 정보) + 기능(메서드)

    #### 1. 기본 문법
    - 클래스 정의 : 정보와 행동을 설명해놓은 틀이라고 생각, 인스턴스 생성을 위한 재료
        ```python
        class Person :
            pass
        print(type(Person)) #클래스의 타입은 타입이다,,,
        ```
    - 인스턴스 생성 : 객체의 설계도(클래스)로 객체(인스턴스)를 생성한다
        ```python
        person1 = Person()
        print(isinstance(person1,Person)) #person1이 Person으로 만든 건지?
        ```        
        - 객체비교
        `==` : 쌍둥이가 생긴 게 같다, 주소가 다르더라도 내용물이 같으면 True
        `is` : 주민번호는 다르다(다른 사람이다), 메모리 주소가 같아 동일한 객체를 가리키는 경우는 True

    - 메서드 호출 : 클래스 안에 있는 함수 -> 함수 실행 위해서는 인스턴스 필요
        - 인스턴스 메서드 : 인스턴스를 처리(인스턴스에 영향)
            인스턴스변수(self) 사용
            >클래스 내부에 정의되는 메서드의 기본
            호출 시, 첫번째 인자로 인스턴스 자신이 self로 전달됨
            =>*self가 있으면 인스턴스 메서드라고 생각!*
            
            +) 매직메서드: `__`가 있는 메서드는 특수 동작을 위해 만들어짐 => 자세한 건 장고에서 배움
        
        - 클래스 메서드 : 클래스를 처리
            클래스 변수(cls) 사용
            > `@classmethod`(데코레이터) 함수 위에 사용하여 정의 후 호출 시, 첫번째 인자로 cls(클래스) 전달
            
            -데코레이터 : 함수 꾸밀 때 함수 위에 `@`와 선언해주며 활용
        => 클래스 변수, 인스턴스 변수 모두 변경하고 싶을 때는 인스턴스 메서드 활용

        - 정적 메서드 : 나머지(클래스, 인스턴스와 상관없을 때)
            > 클래스 안에서 `@staticmethod` 사용        

    - 속성 : 특정 데이터 타입/클래스 객체들이 가지게 될 상태/데이터/정보를 의미
        - 클래스 변수 : 같이 쓰는 것(공통된 속성)
        공통변수 변경하고 싶으면 `{클래스이름}.{클래스변수이름}`으로 변경
        -> 공용 변수이기 때문에 {인스턴스}.{클래스변수} 가능! 
        - 인스턴스 변수 : 각자 쓰는 것(고유한 변수)
        클래스에서 인스턴스를 생성할 때 생성자 메서드(`__init__`) 사용
        **self**.{name}으로 생성, {instance}.{name}으로 호출
        {instance}.{인스턴스변수}가 없으면, 클래스 변수를 가져옴
        = 지역변수 없으면 글로벌 변수 가져오는 것과 비슷함!

    #### 2. 메서드 정리
    - 인스턴스 메서드 
    ```python
    @classmethod
    def classmethod(cls):
        return 'class method',cls
    ```

        - 인스턴스 메서드는 클래스에서 불러올 수 없다
        Class.method() -> 에러
        - 인스턴스에서는 클래스, 스태틱 메서드 모두 접근 가능하다 (LEGB와 비슷,,)

    - 클래스 메서드
    ```python
    @classmethod
    def classmethod(cls):
        return 'class method',cls
    ```
    - 스태틱 메서드 : 인스턴스, 클래스와 관계없는 것을 개발자가 만들고 싶을 때 사용
    ```python
    @staticmethod
    def staticmethod():
        return 'static method'
    ```

## 2. 객체지향의 핵심 개념
> 객체가 서로 소통하면서 동작하도록 프로그램을 개발하는 방법론(패러다임)
객체 : 정보(-클래스변수, 인스턴스 변수), 행동(클래스메서드, 인스턴스메서드, 스태틱 메서드)

[객체 여러개를 다루는 방법]
1. 추상화 <- 변수, 함수, 클래스
복잡한 것은 숨기고, 필요한 것만 드러내기

2. 상속
두 클래스 사이 부모-자식 관계를 정립하는 것
=> 통로를 연결하는 것마냥, 자식(받는-하위)클래스가 만든 것이 아닌데 부모(주는-상위)클래스의 것들을 사용가능함 -> 속성, 행동, 관계 및 제약조건
*모든 클래스는 object를 상속받는다*
    ```python
    class ChildClass(ParentClass): #import 처럼 가져오고 싶을 때 사용
    ```
    - 상속은 어떻게 쓸 수 있는지?
    공통된 코드를 한 클래스로 만들고, 해당 클래스를 상속받음
    => 메서드 재사용으로 수정이 용이함
    - 관련 함수, 메서드
    isinstance(object, Class) : 해당 객체가 해당 클래스로부터 만들어졌는지
    super(). : 자식 클래스에서 부모 클래스를 사용하고 싶은 경우

    상속시 이름공간은 인스턴스-자식클래스-부모클래스

    **[다중 상속]**
    두 개 이상의 클래스를 상속받는 경우
    -> 먼저 상속받은(첫번째) 부모클래스의 것 사용
    - MRO메서드 : 해당 인스턴스의 클래스가 어떤 부모 클래스를 갖는지 확인


3. 다형성
동일한 메서드가 클래스에 따라 다르게 행동할 수 있음을 의미
서로 다른 클래스의 객체들이 *동일한 메시지*에 대해 *다른 방식*으로 응답할 수 있음 (개발자의 의도에 따라)
    - 메서드 오버라이딩(덮어쓰기)
    부모 클래스에서 정의한 메서드를 자식 클래스에서 변경할 수 있음
    -파일 이름은 그대로인데 내용을 덮어쓰는 것과 비슷함
    +) 오버로딩 <- 파이썬에서는 `*args`로 대체되므로 오버로딩이 따로 없음

4. 캡슐화
객체의 일부 구현 내용에 대해 외부로부터의 직접적인 액세스를 차단
    - 접근제어자(Access Modifier) 종류
    Public : 하위클래스 override허용, 일반적으로 작성되는 대다수의 메서드와 속성
    Protected : `_` 언더바 1개로 시작하며, 부모 클래스 내부와 자식클래스에서만 호출 가능, 하위클래스 override허용
    Private : `__` 언더바 2개로 시작하는 메서드나 속성으로, 본 클래스 내부에서만 사용이 가능하며 하위클래스 상속 및 호출 불가능 (직접 접근 불가)

    --
    - 변수에 접근할 수 있는 메서드를 별도 생성 (다이렉트 접근은 X)
    getter 메서드 : 변수 값 조회, @property 데코레이터 사용
    setter 메서드 : 변수 값 변경, @변수.setter 사용

###### [정리]
- 추상화 : 복잡한 거 숨기고, 필요한 거 나타냄
- 상속 : 부모클래스와 자식클래스 간의 관계, 물려받기, 재사용
- 다형성 : 이름은 같은데, 동작은 다른 것으로, 오버라이딩하여 부모로부터 상속받은 것을 그대로 사용하지 않고 자식이 변경하는 것
- 캡슐화 : 민감한 정보 숨기는 것(`_`)으로 getter, setter 메서드 활용

## 2. 에러와 예외
#### 1. 디버깅
> 디버깅이란 잘못된 프로그램을 수정하는 것으로 '버그를 없앤다'는 의미
-버그 : 소프트웨어에서 발생하는 문제
- 에러 메시지가 발생하는 경우
해당 위치를 찾아 메시지 해결
- 로직 에러가 발생하는 경우
명시적인 에러 메시지 없이 예상과 다른 결과가 나온 경우

#### 2. 에러와 예외
###### 1. 문법 에러
- 문법 오류 ; invalid syntax
- 잘못된 할당 ;assign to literal
ex) sum = 5 이후 sum()함수 동작 안됨
###### 2. 예외
문장이나 표현식이 문법적으로 맞더라도 발생하는 에러
- ZeroDivisionError
- NameError ; not defined(이름공간 상에 해당 이름이 없는 경우)
- TypeError ; 데이터 형이 맞지 않는 경우, 필수 인자가 없는 경우
- IndexError ; 인덱스 존재하지 않거나 범위 벗어난 경우

#### 3. 예외처리
- try문
오류 발생할 가능성이 있는 코드를 실행

- except문
예외 발생시 실행됨 => 발생 가능한 에러를 모두 명시하는 것이 좋음
    - as키워드를 활용하여 에러문을 그대로 변수에 할당