# 0725_필기
---
## 데이터 구조의 활용
- 구조를 활용하기 위해서는 **메소드**를 활용
    데이터 구조.method()
    ex) list.append(), string.split()
- 문서 표준에서 확인할 때, []의 경우 선택적 인자

## 1. 시퀀스형
#### 1. 문자열
**[검증메서드]**
- s.find(x) : x의 첫번째 위치를 반환, 없으면 -1 반환 (**오류가 나지 않음**)
- s.index(x) : find와 비슷하지만, **없으면 오류 발생**
    오류가 나는 것은 프로그램이 중단되는 경우
    오류가 나지 않으면 계속 진행된다는 것
- s.isalpha() : 이때 alphabet은 숫자가 아닌 문자를 의미 
- s.isupper() : 대문자인지
- s.islower() : 소문자인지
- s.istitle() : 띄어쓰기 기준 첫글자만 대문자인 타이틀 형식
=> 인자 없이 함수만 호출

**[변경메서드]**
- s.replace(old, new[,count]) : 특정 글자를 새로운 글자로 바꿔 반환, 
count 옵션을 통해 해당 개수만큼만 바꿀 수도 있음
- s.strip([chars]) : 특정 문자 지정하여 제거
    lstrip : 왼쪽(left) 공백(지정X 시) 날리기
    rstrip : 오른쪽(right) 공백 날리기
- s.split() : 특정 단위로 나눠줌
- 'sperator'.join([iterable]) : 구분자를 넣으면서 iterable을 합침 
    split과 반대의 기능이라고 생각할 수 있음
- s.capitalize() : 젤 첫 글자만 대문자, 나머지 소문자로 변경


#### 2. 리스트
> 리스트는 가변형이기 때문에 메모리의 주소가 변하지 않음! id()로 확인 가능
**[값 추가 및 삭제]**
- l.append(x) : 맨 마지막에 x 추가됨
- l.insert(i,x) : 인덱스 i에 항목 삽입 
    리스트 길이보다 i가 큰 경우 오류가 나지 않고, 맨 마지막에 삽입됨
- l.extend(m) : 순회형의 모든 항목을 리스트 끝에 추가 (+= 와 같은 기능)
    리스트와 리스트를 합치는 기능으로 생각!
- l.remove(x) : 리스트 가장 처음에 있는 x 제거
- l.pop() : 가장 마지막에 있는 항목 **반환** 후 제거 
-> 지우는 값을 확인할 수 있음
    l.pop(i)
- l.clear() : 모든 요소 다 지움

**[탐색 및 정렬]**
- l.index(x): 해당 인덱스 값을 반환
- l.sort(): 원본 리스트를 정렬함, None 반환
    cf) sorted() : 원본을 바꾸는 것이 아니며, 정렬한 반환값을 갖는다
- l.reverse() : 원본을 반대로 뒤집기 때문에, None 반환


#### 3. 튜플
> 튜플 자체를 변경할 수는 없음 -> 불변형
    확장연산자는 가능하여, 원본 변경이 아니라 튜플을 활용할 수는 있음
    **print(id())로 확인 결과 메모리 주소는 다름**

**[연산자]**
- 멤버십 연산자 : 포함 여부 확인
    - in : 포함되는지 확인
    - not in : 포함 안되어있는지 확인
- 시퀀스형 연산자
    - 산술연산자 : 시퀀스 간 연결/연쇄
    - 반복연산자(*) : 시퀀스를 반복
        range()의 경우 에러

## 2. 비시퀀스형
#### 1. 셋(set)
> 요소의 삽입, 변경, 삭제 가능한 가변형

**[추가 및 변경]**
- s.add(elem) : set은 순서가 없기 때문에 print 할 때마다 순서가 달라질 수 있음
- s.update(*others) : 기존 셋에 여러 값을 추가할 때(리스트형태,,) 사용가능

**[요소 삭제]**
- s.remove(elem) : 해당 요소 삭제, 항목 존재하지 않을 경우 에러 뜸
- s.discard(elem): 해당 요소를 삭제, 존재하지 않은 경우에도 에러는 뜨지 않음
- s.pop() : 임의의 원소 반환과 제거
- s.clear() : 모두 없애기

**[집합관련]**
- s.isdisjoint(t) : 서로소(교집합이 없는) 경우 True 반환
- s.issubset(t) : s가 t의 하위셋인 경우
- s.issuperset(t): s가 t의 상위셋인 경우
    s가 주어!


#### 2. 딕셔너리(dictionary)
**[조회]**
- d.get(key) : 없는 키를 조회하는 경우에도, keyerror가 발생하지 않고 None값 반환

**[추가 및 삭제]**
- d.pop(key) : 키가 존재하면 제거하고, 해당 값을 반환
- d.update(키=value) : 해당 키의 값을 덮어쓸 수 있음
 
**[순회]**
 - d.keys()
 - d.values()
 - d.items() : key, value를 튜플로 반환

---
## 깊은 복사와 얕은 복사
- 깊은 : 쌍둥이 같은 것
- 얕은 : 분신술 같은 것

#### 복사
1. 할당
- 대입연산자(=)로 할당 가능
대입연산자를 통한 복사는 해당 객체에 대한 객체 참조를 복사
=> 오리지널과 카피가 메모리 주소를 공유하기 때문
```python
original_list = [1,2,3]
copy_list = original_list
print(original_list, copy_list)

copy_list[0] = 'hello'
print(original_list, copy_list) 
#['hello', 2, 3] ['hello', 2, 3]
```

2. 얕은 복사
- slice 연산자를 활용하여 다른 주소에 원본을 복사
```python
a = [1, 2, 3]
b = a[:] #내용물을 그대로 복사해줌
b[0] = 5
print(a,b)
#[1, 2, 3] [5, 2, 3]
```
but, 2차원리스트는 막을 수 없음

3. 깊은 복사
> 2차원 리스트의 공유를 막기 위해서 깊은 복사를 사용

```python
import copy
a = [1,2,['a', 'b']]
copy.deepcopy(a) 
```

